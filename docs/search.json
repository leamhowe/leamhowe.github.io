[
  {
    "objectID": "resources.html",
    "href": "resources.html",
    "title": "Resources",
    "section": "",
    "text": "Here we list a bunch of useful resources for getting started with geospatial machine learning."
  },
  {
    "objectID": "resources.html#intro-to-geoml",
    "href": "resources.html#intro-to-geoml",
    "title": "Resources",
    "section": "Intro to GeoML",
    "text": "Intro to GeoML\nOpen Access Courses:\n\nGeoSMART Curriculum\nWV View courses in GIS, remote sensing, and geospatial deep learning.\nRadiantEarth ML4EO Bootcamp 2021\n\nOther resources:\n\nTorchgeo Tutorials: The  package is an extension to PyTorch to include popular datasets, model architectures, and common image transformations for geospatial data."
  },
  {
    "objectID": "members.html",
    "href": "members.html",
    "title": "Members",
    "section": "",
    "text": "ML4GEO is a cross-school community of researchers interested in collaborating and learning from each other on topics related to Machine Learning in Geoscience and Earth Observation.\nIf you are based at the University of Edinburgh and would like to be added to the website as a member of ML4GEO, please fill in this form."
  },
  {
    "objectID": "members.html#ml4geo-members",
    "href": "members.html#ml4geo-members",
    "title": "Members",
    "section": "ML4GEO Members",
    "text": "ML4GEO Members\n\n\n\n  \n  \n    \n      \n    \n    Leam Howe\n    Email: leam.howe@ed.ac.uk\n    Position: PhD Student, SENSE CDT, School of GeoSciences\n    Research Topics: Snow, Scotland, Remote Sensing, Modelling, Machine Learning.\n\n  \n\n\n\n  \n  \n    \n      \n        \n    Becky Wilks\n    Email: R.C.Wilks@sms.ed.ac.uk\n    Position: PhD Student, SENSE CDT, School of Mathematics\n    Research Topics: Elephants, Wildlife Monitoring, Remote Sensing, Statistical Modelling, Machine Learning.\n    \n\n  \n  \n    \n        \n    \n    Philipp Barthelme\n    Email: philipp.barthelme@ed.ac.uk\n    Position: PhD Student, SENSE CDT, School of GeoSciences\n    Research Topics: Conflict, Environment, Remote Sensing, Machine Learning, Vietnam War.\n  \n\n  \n  \n    \n        \n    \n    Seán Ó Héir\n    Email: sean.oheir@ed.ac.uk\n    Position: PhD Student, SENSE CDT, School of Informatics\n    Research Topics: Population Estimation, Remote Sensing, Machine Learning.\n      \n  \n  \n  \n    \n        \n    \n    Foteini Dervisi\n    Email: F.Dervisi@sms.ed.ac.uk\n    Position: PhD Student, SENSE CDT, School of GeoSciences\n    Research Topics: Earthquake forecasting, Remote Sensing, Machine Learning."
  },
  {
    "objectID": "gee_patch_vis.html",
    "href": "gee_patch_vis.html",
    "title": "Leam Howe",
    "section": "",
    "text": "import numpy as np\nimport plotly.express as px\nfrom plotly.subplots import make_subplots\nfrom dash import Dash, html, dcc, Input, Output, no_update, callback, State, callback_context\nfrom skimage import data, draw\nfrom scipy import ndimage\nfrom skimage import io\nimport os\nimport json\n\nfrom geemap import ee_to_numpy\n\n\nfrom google.oauth2 import service_account\nimport ee\nfrom pathlib import Path\n\n# Define the required scopes\nscopes = ['https://www.googleapis.com/auth/earthengine', \n          'https://www.googleapis.com/auth/devstorage.read_write']\n\n# Use the service account JSON key path and scopes \ncredentials = service_account.Credentials.from_service_account_file(\n    # '/home/users/leamhowe/ee-credentials/ee-snow-patches-81eaf6e60bf9.json',\n    Path(r'C:\\Users\\s2112771\\Documents\\ee-credentials\\ee-snow-patches-81eaf6e60bf9.json'),\n    scopes=scopes)\n\n# Initialize the Earth Engine API with the credentials\nee.Initialize(credentials)\nee.Authenticate()\n\nTrue\n\n\n\ndef get_false_color_image(timestep_idx):\n    \"\"\"Helper function to get false color image for a given timestep index\"\"\"\n    image = ee.Image(image_list.get(timestep_idx))\n    # image = set_clouds_to_value(image)  # Apply cloud mask\n    bands = ['B11', 'B8', 'B3'] # B11 (SWIR), B4 (Red), B3 (Green)... good for distinguishing snow from cloud\n    # bands = ['B4', 'B3', 'B2'] # B11 (SWIR), B4 (Red), B3 (Green)... good for distinguishing snow from cloud\n    resampled = image.select(bands).resample().reproject(image.select('B2').projection())\n    region_image = resampled.clip(aoi)\n    image_array = ee_to_numpy(region_image, region=aoi, scale=pixel_size) \n\n    image_id = image.get('system:index').getInfo()  # Get the image ID\n\n    return image_array, image_id\n\ndef get_true_color_image(timestep_idx):\n    \"\"\"Helper function to get false color image for a given timestep index\"\"\"\n    image = ee.Image(image_list.get(timestep_idx))\n    # image = set_clouds_to_value(image)  # Apply cloud mask\n    # bands = ['B11', 'B4', 'B3'] # B11 (SWIR), B4 (Red), B3 (Green)... good for distinguishing snow from cloud\n    bands = ['B4', 'B3', 'B2'] # true color bands\n    resampled = image.select(bands).resample().reproject(image.select('B2').projection())\n    region_image = resampled.clip(aoi)\n    image_array = ee_to_numpy(region_image, region=aoi, scale=pixel_size) \n\n    image_id = image.get('system:index').getInfo()  # Get the image ID\n\n    return image_array, image_id\n\n\n            \n            \n\n\n\nlocation, lon, lat = 'Garbh_Choire_Mor',  -3.744673,  57.060077\n\n# -36.39952 148.31508   2030    2   Blue Lake Upper NSW\n# -36.40363 148.31204   1905    4   Blue Lake Lower NSW\n# location, lon, lat = 'Blue Lake Upper', 148.31508, -36.39952\n# location, lon, lat = 'Blue Lake Lower', 148.31204, -36.40363\n\nstart_date = '2025-07-12'\nend_date = '2025-07-14'\noriginal_size=100\n\n# Satellite Data\n# da = cubo.create(lat=lat, lon=lon, collection=ee.ImageCollection(\"COPERNICUS/S2_HARMONIZED\"),\n#                     bands=s2l1c_bands_gee, \n#                     start_date=start_date, end_date=end_date,\n#                     edge_size=original_size, resolution=10, gee=True, chunk_size=1000,)\n\n# using gee python API\n# create a point geometry for the location\npoint = ee.Geometry.Point([ lon, lat]) \n# Define pixel size and region dimensions\npixel_size = 10  # Sentinel-2 native resolution (meters)\nregion_size = 98  # 100 pixels\nbuffer_distance = (region_size * pixel_size) / 2  # 500 meters (100px * 10m/px / 2)\n\n# Create a square region around the point\naoi = point.buffer(buffer_distance).bounds()\n\n\n\ns2_toa = ee.ImageCollection('COPERNICUS/S2_HARMONIZED') # Sentinel-2 TOA\n\nfiltered = (s2_toa\n    .filterBounds(point).filterDate(start_date, end_date)\n    # .linkCollection(csPlus, ['cs_cdf'])  # Join with Cloud Score+\n    # .map(set_clouds_to_value)  # Apply cloud replacement\n    # .first()  # Get the first image\n)\n# get a list of the images in the collection\nimage_list = filtered.toList(filtered.size())\n# Get the number of images in the collection\ncount = image_list.size().getInfo()\n\n\nfc_image, image_id = get_false_color_image(0)\nrgb_image, image_id = get_true_color_image(0)\nvmin = np.percentile(rgb_image, 1)\nvmax = np.percentile(rgb_image, 99)\nfig = px.imshow(rgb_image, binary_string=True, origin='lower', \n                zmin=vmin, zmax=vmax, aspect=3.5/5.5,\n                title=image_id \n                )\n\n\nfig.update_xaxes(showticklabels=False, title=None)\nfig.update_yaxes(showticklabels=False, title=None)\n\nfig.show()\n\n\n            \n            \n\n\nUnable to display output for mime type(s): application/vnd.plotly.v1+json\n\n\n\nvmin_fc\n\n\n            \n            \n\n\nnp.float64(731.0)\n\n\n\nfrom plotly.subplots import make_subplots\nimport plotly.graph_objects as go\nimport numpy as np\n\n# Get images\nfc_image, image_id = get_false_color_image(0)\nrgb_image, _ = get_true_color_image(0)\n\n# Normalize RGB image manually\nvmin_rgb = np.percentile(rgb_image, 1)\nvmax_rgb = np.percentile(rgb_image, 99)\nrgb_image_scaled = np.clip((rgb_image - vmin_rgb) / (vmax_rgb - vmin_rgb), 0, 1)\nrgb_image_scaled = (rgb_image_scaled * 255).astype(np.uint8)\n\n# Normalize FC image manually\nvmin_fc = np.percentile(fc_image, 1)\nvmax_fc = np.percentile(fc_image, 99)\nfc_image_scaled = np.clip((fc_image - vmin_fc) / (vmax_fc - vmin_fc), 0, 1)\nfc_image_scaled = (fc_image_scaled * 255).astype(np.uint8)\n\n# Create subplot\nfig = make_subplots(rows=1, cols=2, subplot_titles=(\"True Color\", \"False Color\"))\n\n# Add True Color\nfig.add_trace(go.Image(z=rgb_image_scaled), row=1, col=1)\n\n# Add False Color\nfig.add_trace(go.Image(z=fc_image_scaled), row=1, col=2)\n\n# Hide axes, update layout\nfig.update_layout(\n    title_text=f\"Image ID: {image_id}\",\n    showlegend=False,\n    margin=dict(l=0, r=0, t=30, b=0)\n)\n\nfig.update_xaxes(showticklabels=False, title=None)\nfig.update_yaxes(showticklabels=False, title=None)\n\nfig.show()\n\n\n            \n            \n\n\nUnable to display output for mime type(s): application/vnd.plotly.v1+json\n\n\n\ndef get_image_array(timestep_idx, bands, region, scale, image_list):\n    \"\"\"Fetch an image and return it as a NumPy array.\"\"\"\n    image = ee.Image(image_list.get(timestep_idx))\n    resampled = image.select(bands).resample().reproject(image.select('B2').projection())\n    region_image = resampled.clip(region)\n    image_array = ee_to_numpy(region_image, region=region, scale=scale)\n    image_id = image.get('system:index').getInfo()\n    return image_array, image_id\n\n\n            \n            \n\n\n\n# For true color:\nrgb_image, image_id = get_image_array(0, bands=['B4', 'B3', 'B2'], region=aoi, scale=pixel_size, image_list=image_list)\n\n# For false color:\nfc_image, _ = get_image_array(0, bands=['B11', 'B4', 'B3'], region=aoi, scale=pixel_size, image_list=image_list)\n\n\n            \n            \n\n\n\nfrom plotly.subplots import make_subplots\nimport plotly.express as px\nimport numpy as np\n\n# Get images\nrgb_image, image_id = get_image_array(0, ['B4', 'B3', 'B2'], aoi, pixel_size, image_list)\nfc_image, _ = get_image_array(0, ['B11', 'B4', 'B3'], aoi, pixel_size, image_list)\n\n# Compute contrast bounds\nvmin_rgb = np.percentile(rgb_image, 1)\nvmax_rgb = np.percentile(rgb_image, 99)\nvmin_fc = np.percentile(fc_image, 1)\nvmax_fc = np.percentile(fc_image, 99)\n\n# Use px.imshow for contrast stretching, then extract trace\nfig_rgb = px.imshow(rgb_image, zmin=vmin_rgb, zmax=vmax_rgb, binary_string=True)\nfig_fc = px.imshow(fc_image, zmin=vmin_fc, zmax=vmax_fc, binary_string=True)\n\n# Create subplot\nfig = make_subplots(rows=1, cols=2, subplot_titles=[\"True Color\", \"False Color\"])\nfig.add_trace(fig_rgb.data[0], row=1, col=1)\nfig.add_trace(fig_fc.data[0], row=1, col=2)\n\n# Layout adjustments\nfig.update_layout(\n    title_text=f\"Image ID: {image_id}\",\n    title={'x': 0.5},\n    height=600,\n    margin=dict(l=0, r=0, t=80, b=10)\n)\n\n# Preserve aspect ratio\nfig.update_yaxes(scaleanchor=\"x\", row=1, col=1)\nfig.update_yaxes(scaleanchor=\"x\", row=1, col=1)\n\n# Remove axis ticks\nfig.update_xaxes(showticklabels=False)\nfig.update_yaxes(showticklabels=False)\n\nfig.show()\n\n\n            \n            \n\n\nUnable to display output for mime type(s): application/vnd.plotly.v1+json\n\n\n\nimport geemap\n\n# Plot the true color image using geemap\ngeemap.imshow(rgb_image, title=f\"True Color - {image_id}\")\n\n\n            \n            \n\n\n\n---------------------------------------------------------------------------\nAttributeError                            Traceback (most recent call last)\nCell In[72], line 4\n      1 import geemap\n      3 # Plot the true color image using geemap\n----&gt; 4 geemap.imshow(rgb_image, title=f\"True Color - {image_id}\")\n\nAttributeError: module 'geemap' has no attribute 'imshow'\n\n\n\n\nimport geemap\nimport ee\n\ndef plot_image_geemap(timestep_idx, bands, vis_params=None, region=None, zoom=10):\n    \"\"\"Display a single image from image_list on an interactive geemap map.\"\"\"\n    image = ee.Image(image_list.get(timestep_idx))\n    image = image.select(bands)\n\n    # Center on the region if given, else center on image centroid\n    # if region:\n    #     center = region.centroid().coordinates().getInfo()\n    # else:\n    #     center = image.geometry().centroid().coordinates().getInfo()\n    center = region.centroid().coordinates().getInfo() if region else image.geometry().centroid().coordinates().getInfo()\n\n    # Set default visualization parameters if none provided\n    if vis_params is None:\n        vis_params = {\n            'min': 0,\n            'max': 3000,  # Sentinel-2 reflectance scale\n            'bands': bands\n        }\n\n    # Create the map\n    Map = geemap.Map(center=center[::-1], zoom=zoom)  # reverse lat/lon for center\n    Map.addLayer(image.clip(region if region else image.geometry()), vis_params, 'Image')\n    Map.addLayer(region, {}, 'AOI') if region else None\n    Map.addLayerControl()\n    return Map\n\n# Example usage: True color\ntrue_color_map = plot_image_geemap(\n    timestep_idx=0,\n    bands=['B4', 'B3', 'B2'],  # true color\n    vis_params={'min': 0, 'max': 3000, 'bands': ['B4', 'B3', 'B2']},\n    region=aoi,\n    zoom=10\n)\ntrue_color_map\n\n\n            \n            \n\n\n\n---------------------------------------------------------------------------\nHttpError                                 Traceback (most recent call last)\nFile c:\\Users\\s2112771\\miniconda3\\envs\\geo\\Lib\\site-packages\\ee\\data.py:408, in _execute_cloud_call(call, num_retries)\n    407 try:\n--&gt; 408   return call.execute(num_retries=num_retries)\n    409 except googleapiclient.errors.HttpError as e:\n\nFile c:\\Users\\s2112771\\miniconda3\\envs\\geo\\Lib\\site-packages\\googleapiclient\\_helpers.py:134, in positional.&lt;locals&gt;.positional_decorator.&lt;locals&gt;.positional_wrapper(*args, **kwargs)\n    133         logger.warning(message)\n--&gt; 134 return wrapped(*args, **kwargs)\n\nFile c:\\Users\\s2112771\\miniconda3\\envs\\geo\\Lib\\site-packages\\googleapiclient\\http.py:915, in HttpRequest.execute(self, http, num_retries)\n    914 if resp.status &gt;= 300:\n--&gt; 915     raise HttpError(resp, content, uri=self.uri)\n    916 return self.postproc(resp, content)\n\nHttpError: &lt;HttpError 400 when requesting https://earthengine.googleapis.com/v1/projects/earthengine-legacy/value:compute?prettyPrint=false&alt=json returned \"Geometry.centroid: Unable to perform this geometry operation. Please specify a non-zero error margin.\". Details: \"Geometry.centroid: Unable to perform this geometry operation. Please specify a non-zero error margin.\"&gt;\n\nDuring handling of the above exception, another exception occurred:\n\nEEException                               Traceback (most recent call last)\nCell In[75], line 32\n     29     return Map\n     31 # Example usage: True color\n---&gt; 32 true_color_map = plot_image_geemap(\n     33     timestep_idx=0,\n     34     bands=['B4', 'B3', 'B2'],  # true color\n     35     vis_params={'min': 0, 'max': 3000, 'bands': ['B4', 'B3', 'B2']},\n     36     region=aoi,\n     37     zoom=10\n     38 )\n     39 true_color_map\n\nCell In[75], line 14, in plot_image_geemap(timestep_idx, bands, vis_params, region, zoom)\n      7 image = image.select(bands)\n      9 # Center on the region if given, else center on image centroid\n     10 # if region:\n     11 #     center = region.centroid().coordinates().getInfo()\n     12 # else:\n     13 #     center = image.geometry().centroid().coordinates().getInfo()\n---&gt; 14 center = region.centroid().coordinates().getInfo() if region else image.geometry().centroid().coordinates().getInfo()\n     16 # Set default visualization parameters if none provided\n     17 if vis_params is None:\n\nFile c:\\Users\\s2112771\\miniconda3\\envs\\geo\\Lib\\site-packages\\ee\\computedobject.py:107, in ComputedObject.getInfo(self)\n    101 def getInfo(self) -&gt; Optional[Any]:\n    102   \"\"\"Fetch and return information about this object.\n    103 \n    104   Returns:\n    105     The object can evaluate to anything.\n    106   \"\"\"\n--&gt; 107   return data.computeValue(self)\n\nFile c:\\Users\\s2112771\\miniconda3\\envs\\geo\\Lib\\site-packages\\ee\\data.py:1128, in computeValue(obj)\n   1125 body = {'expression': serializer.encode(obj, for_cloud_api=True)}\n   1126 _maybe_populate_workload_tag(body)\n-&gt; 1128 return _execute_cloud_call(\n   1129     _get_cloud_projects()\n   1130     .value()\n   1131     .compute(body=body, project=_get_projects_path(), prettyPrint=False)\n   1132 )['result']\n\nFile c:\\Users\\s2112771\\miniconda3\\envs\\geo\\Lib\\site-packages\\ee\\data.py:410, in _execute_cloud_call(call, num_retries)\n    408   return call.execute(num_retries=num_retries)\n    409 except googleapiclient.errors.HttpError as e:\n--&gt; 410   raise _translate_cloud_exception(e)\n\nEEException: Geometry.centroid: Unable to perform this geometry operation. Please specify a non-zero error margin."
  },
  {
    "objectID": "committee.html",
    "href": "committee.html",
    "title": "Committee",
    "section": "",
    "text": "Are you interested in encouraging interdisciplinary collaboration at the intersection of machine learning and geosciences? Join our committee to help shape future events and initiatives! Roles are flexible depending on your time constraints. If you are interested please contact one of the committee for more infomation."
  },
  {
    "objectID": "committee.html#meet-the-team-2024-25",
    "href": "committee.html#meet-the-team-2024-25",
    "title": "Committee",
    "section": "Meet the team 2024-25",
    "text": "Meet the team 2024-25\n\n\n\n  \n  \n    \n      \n    \n    Leam Howe\n    Email: leam.howe@ed.ac.uk\n    Position: PhD Student, SENSE CDT, School of GeoSciences\n    Research Topics: Snow, Scotland, Remote Sensing, Modelling, Machine Learning.\n\n  \n\n\n\n  \n  \n    \n      \n        \n    Becky Wilks\n    Email: R.C.Wilks@sms.ed.ac.uk\n    Position: PhD Student, SENSE CDT, School of Mathematics\n    Research Topics: Elephants, Wildlife Monitoring, Remote Sensing, Statistical Modelling, Machine Learning.\n    \n\n  \n  \n    \n        \n    \n    Philipp Barthelme\n    Email: philipp.barthelme@ed.ac.uk\n    Position: PhD Student, SENSE CDT, School of GeoSciences\n    Research Topics: Conflict, Environment, Remote Sensing, Machine Learning, Vietnam War.\n  \n\n  \n  \n    \n        \n    \n    Seán Ó Héir\n    Email: sean.oheir@ed.ac.uk\n    Position: PhD Student, SENSE CDT, School of Informatics\n    Research Topics: Population Estimation, Remote Sensing, Machine Learning.\n      \n  \n  \n  \n    \n        \n    \n    Foteini Dervisi\n    Email: F.Dervisi@sms.ed.ac.uk\n    Position: PhD Student, SENSE CDT, School of GeoSciences\n    Research Topics: Earthquake forecasting, Remote Sensing, Machine Learning."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "events.html",
    "href": "events.html",
    "title": "Events",
    "section": "",
    "text": "This page lists all upcoming ML4GEO events. Please bear in mind that the MS Teams Channel will remain the place to receive the most up-to-date information about ML4GEO activities.\n\n\n22/07/2025 - Geospatial Foundation Models Ideathon/Hackathon\nML4GEO is a research group passionate about connecting geospatial sciences with machine learning!\nThis month, we’re excited to host our inaugural Ideathon/Hackathon focused on Geospatial Foundation Models! Join us at ML4GEO for a 2-day event on July 22-23 at the Edinburgh Futures Institute. where we’ll collaborate to generate ideas and explore use cases together. No technical expertise required!\nGeospatial Foundation models (GFMs) are revolutionising geospatial machine learning (TerraMind, SSL4EO-S12 , Google Embeddings,… ) with state-of-the-art performance and generalizability across sensors/regions and benchmark spatial imaging tasks.\nOur Ideathon/Hackathon aims to: * Provide a brief introduction to GFMs. * Offer space for discussion and idea generation for applications. * Facilitate group work to develop prototypes and implement ideas using actual GFMs and FM embeddings.\nYou’ll have the opportunity to identify your own problem and choose which GFM and data to use, facilitating a self-driven learning experience!\nSign-ups here!"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "\nLeam Howe\n",
    "section": "",
    "text": "Leam Howe\n\n\nPhD Student, SENSE CDTSchool of GeoSciences, University of Edinburgh\n\n\nleam.howe@ed.ac.uk\n\n\n\n\nAbout\nPhD researcher with a particular focus on remote sensing and Earth observation from space. Keen on utilising machine learning to capitalise on these rapidly expanding datasets. Partial to mountains, snow, and coffee.\n\n\n\nResearch Interests\n\nEarth Observation\n\nRemote Sensing\n\nAI & Machine Learning\n\nClimate Change\n\nThe Cryosphere\n\nSnow\n\nOrographic Processes\n\nMountain Meteorology\n\n\n\n\nPrevious Studies\n\nMSci (Hons) Physics, University of Nottingham\n\nMRes Climate and Atmospheric Science, University of Leeds\n\n\n\n\nAffiliations\n\nSENSE Earth Observation CDT\n\nENVEO IT GmbH"
  },
  {
    "objectID": "phd-project.html",
    "href": "phd-project.html",
    "title": "Leam Howe",
    "section": "",
    "text": "“MACHINE LEARNING FOR REMOTE SENSING AND MODELLING OF MOUNTAIN SNOW PATCHES”\n\n\n\nScientific Background and Motivation\n\nAnthropogenic climate change is causing the mountain cryosphere (snow, ice, and permafrost) to deteriorate rapidly — a trend expected to accelerate over coming decades. The impacts will extend far beyond the mountains to affect physical, biological, and human systems in surrounding lowlands and oceans.\nMountain snow provides many services as a water store, habitat, and playground, but also poses risks (floods, avalanches) due to its high climate sensitivity.\nThe high spatial variability of snow in mountains makes it difficult to monitor and forecast using coarse-resolution satellite sensors and models — even though these environments need such forecasts most.\nEven in Scotland’s maritime climate, snow can persist all summer in sheltered mountain spots. Some corries hosted perennial snow patches for decades until recently. Predicting the fate of these patches is a good test for physically-based snow models used in climate studies.\nThis project leverages new high-resolution remote sensing and meteorological modelling to better understand the climate sensitivity of mountain snow.\n\n\n\n\nFalse-colour image over the cairngorms from Sentinel-2\n\n\n\n\n\n\nAims and Objectives\nArtificial Neural Networks (ANNs) will be applied to three main challenges:\n\nRemote sensing of mountain snow cover in Scotland\n\nDownscaling meteorological variables over mountain topography\n\nConstraining physical snow models using remote sensing and meteorological data\n\n\n\n\nMethodology\nStep 1 – Remote Sensing of Snow Cover\nTraditional methods use reflectance differences (visible vs. near-infrared) to distinguish snow from cloud, then thresholding for snow classification. But multispectral sensors and snow reflectance models hold much more information — about grain size, contaminants, etc.\nMachine learning (ANNs) will be trained to classify snow using: - MODIS - Sentinel-2 - Potentially SAR (Synthetic Aperture Radar)\nTraining data will be tailored for conditions specific to the Cairngorms.\nStep 2 – Downscaling Meteorology\nWeather stations are sparse and hard to maintain in the mountains (see example below):\n\n\n\n\nCairngorm summit weather station frozen solid and recording little data.\n\n\n\nModern high-resolution meteorological models (e.g., NWP, CFD) can help but are limited in coverage. Machine learning will be used to downscale meteorological inputs like wind and precipitation, which do not follow simple elevation-based rules.\nStep 3 – Physically-Based Snow Modelling\nA high-resolution snow model will be: - Driven by downscaled meteorological inputs - Evaluated using remote sensing snow products\nThe model will account for: - Well-understood processes (e.g. shading) - Poorly understood processes (e.g. wind erosion, turbulent transport)\nMachine learning will help integrate these processes under physical constraints like mass and energy conservation.\nFieldwork will focus on the Cairngorms and surrounding catchments (Feshie, Coire Cas), allowing quick response to weather and reducing carbon footprint."
  }
]